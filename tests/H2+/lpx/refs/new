      subroutine initwavefunc()

        implicit none
        complex(dp) :: olap
        complex(dp) :: auxphin(nrprimn), auxphin2(nrprimn), auxphin3(nrprimn)
        complex(dp), allocatable :: projP(:,:)
        real(dp)     :: work(3*nrprime), w(nrprime)
        real(dp)     :: workn(3*nrprimn), wn(nrprimn)
        real(dp)     :: norm
        real(dp)     :: norm_spinorbital
        real(dp)     :: h2(nrprime,nrprime)
        real(dp)     :: hnuc(nrprimn,nrprimn)
        real(dp)     :: rep(nrorb), imp(nrorb), rea, ima
        real(dp)     :: rep_spinorbital(nrorb_spinorbital),imp_spinorbital(nrorb_spinorbital), rea_spinorbital, ima_spinorbital
        integer(i64) :: planf, planb
        integer      :: mu, nu, in, ix, jx
        integer      :: i, j
        integer      :: scfvals
        integer      :: fftw_forward=-1,fftw_backward=1
        integer      :: info, lwork
        integer      :: spsi
        integer      :: init_coef_A, sum_sz_tmp, detl_spinorbital_count, nel_count, flag_print
        character(3) :: jobz, uplo, ncol
        character(3) :: nnn

        write (*,*) 'nsz in begining of initwavefunc', nsz
        if (restart == 2 .or. restart == 5) then
          nnn = stri(2*nrorb)
          if (flag_spinorbital==0) then
            open(newunit=spsi,file="startpsi")
            do i=1, nrindep*nrspf
              read(spsi,*) rea, ima
              A(i) = dcmplx(rea,ima)
            end do

            do mu=1, nrprime
              read(spsi,'('//stri(2*nrorb)//'(e23.16,1x))') (rep(in),in=1,nrorb), (imp(in),in=1,nrorb)
              do in=1, nrorb
                phi(mu,in) = dcmplx(rep(in),imp(in))
              enddo
            enddo

            write(ncol,'(i1)') 2*nrspf

            do ix=1, nrprimn
              read(spsi,'('//stri(2*nrspf)//'(e23.16,1x))') (rep(in),in=1,nrspf), (imp(in),in=1,nrspf)
              do in=1, nrspf
                phin(ix,in) = dcmplx(rep(in),imp(in))
              enddo
            enddo
            close(spsi)

          else if (flag_spinorbital==1) then
            open(newunit=spsi,file="startpsi_spinorbital")
            do i=1, nrindep_spinorbital*nrspf
              read(spsi,*) rea_spinorbital, ima_spinorbital
              A_spinorbital(i) = dcmplx(rea_spinorbital,ima_spinorbital)
            end do
            do mu=1, nrprime
              read(spsi,'('//stri(nrorb_spinorbital)//'(e23.16,1x))') (rep_spinorbital(in),in=1,nrorb_spinorbital)
              read(spsi,'('//stri(nrorb_spinorbital)//'(e23.16,1x))') (imp_spinorbital(in),in=1,nrorb_spinorbital)
              do in=1, nrorb_spinorbital
                phi_spinorbital(mu,in) = dcmplx(rep_spinorbital(in),imp_spinorbital(in))
              enddo
            enddo

            write(ncol,'(i1)') 2*nrspf

            do ix=1, nrprimn
              read(spsi,'('//stri(2*nrspf)//'(e23.16,1x))') (rep_spinorbital(in),in=1,nrspf), (imp_spinorbital(in),in=1,nrspf)
              do in=1, nrspf
                phin(ix,in) = dcmplx(rep_spinorbital(in),imp_spinorbital(in))
              enddo
            enddo

            close(spsi)

          else
            write (*,*) 'flag_spinorbital not 0/1, supported'
            stop
          end if

        !> If this isn't a restart then initialize the wavefunction from the scf guess vals
        else if (restart == 0) then
          A(:) = c0
          A(1) = cr
          if (nsz == 0) then
            A(1) = cr
          end if

          A_spinorbital(:) = c0
          sum_sz_tmp = 0
          detl_spinorbital_count = 1
          nel_count = 0
          if (flag_spinorbital == 1) then
            do i = 1, nrindep_spinorbital*nel
               nel_count = nel_count +1
               if (mod(detl_spinorbital(i),2) == 0) then
                 sum_sz_tmp = sum_sz_tmp - 1
               else if (mod(detl_spinorbital(i),2) == 1) then
                 sum_sz_tmp = sum_sz_tmp + 1
               else
                 write (*,*) 'error in mod 2'
                 stop
               end if

               if (sum_sz_tmp == nsz .and. nel_count == nel)  then
                 write (*,*) 'match v2', detl_spinorbital_count
                 init_coef_A = detl_spinorbital_count
                 exit
               end if

               if (mod(i,nel) == 0) then
                 sum_sz_tmp = 0
                 nel_count = 0
                 detl_spinorbital_count = detl_spinorbital_count + 1
               end if

            end do

            if (nsz == 0) then
              A_spinorbital(1) = cr
            else
               A_spinorbital(init_coef_A) = cr
            end if
          end if

          ! generalized option, read in SCF energies from run on each grid point
          write (*,*) "scfv_path", scfv_path
          write (*,*) "scfvals", scfvals
          open(newunit=scfvals, file=trim(scfv_path), status='old')
          ! in init, we setup electronic Hamiltonian, now we set up nuclear part
          do ix=1, nrprimn
            do jx=1, nrprimn
              hnuc(ix,jx) = 0.0_dp
            enddo
            read(scfvals,*) hnuc(ix,ix)
          enddo
          close(scfvals)

          if (mod(nrprimn,2) == 0) then
          ! add kinetic term for nuclear Hamiltonian
            do ix=1, nrprimn
              do jx=1, nrprimn
                if (ix == jx) then
                  hnuc(ix,ix) = hnuc(ix,ix) + pi**2*(nrprimn**2 + 2)/(6.0_dp*massn*nrprimn**2*dr**2)
                else
                  hnuc(ix,jx) = ((-1.0_dp)**(ix - jx))*pi**2/((nrprimn*dr*dsin(dble(ix - jx)*pi/dble(nrprimn)))**2*massn)
                endif
              enddo
            enddo

          else
            do ix=1, nrprimn
              do jx=1, nrprimn
                if (ix == jx) then
                !  Tannor, quantum mechanics time-dependent perspective, p 307, 11.172
                  hnuc(ix,ix) = hnuc(ix,ix) + pi**2*(nrprimn**2 + 1)/(6.0_dp*massn*nrprimn**2*dr**2)
                else
                  hnuc(ix,jx) = ((-1.0_dp)**(ix - jx))*pi**2* dcos( dble(ix - jx)*pi/dble(nrprimn) ) &
  & /((nrprimn*dr*dsin(dble(ix - jx)*pi/dble(nrprimn)))**2*massn)
                endif
              enddo
            enddo
          end if

          jobz = "V"
          uplo = "U"
          lwork = 3*nrprimn

          call dsyev(jobz,uplo,nrprimn,hnuc,nrprimn,wn,workn,lwork,info)
          phin(:,:) = c0
          do ix=1, nrprimn
            do i=1, nrspf
              phin(ix,i) = -hnuc(ix,i)
              phin_spinorbital(ix,i) = -hnuc(ix,i)
            enddo
          enddo

          do i=1, nrspf
            norm = 0.0_dp
            norm_spinorbital = 0.0_dp
            do ix=1, nrprimn
              norm             = norm + dconjg(phin(ix,i))*phin(ix,i)
              norm_spinorbital = norm_spinorbital + dconjg(phin_spinorbital(ix,i))*phin_spinorbital(ix,i)
            enddo
            norm = dsqrt(norm*dr)
            norm_spinorbital = dsqrt(norm_spinorbital*dr)
            do ix=1, nrprimn
              phin(ix,i) = phin(ix,i)/norm
              phin_spinorbital(ix,i) = phin_spinorbital(ix,i)/norm_spinorbital
            enddo
          enddo
          call compare_scalar_real(norm,norm_spinorbital)

          lwork = 3*nrprime
          h2(:,:) = hmat(:,:,inigrd)

          call dsyev(jobz,uplo,nrprime,h2,nrprime,w,work,lwork,info)

          do mu=1, nrprime
            do i=1, nrorb
              !> I suppose if we wanted to keep virtuals we could compute a full nrprime x nrprime matrix
              !> or in the case we want to swap orbitals around, which might need to happen
              phi(mu,i) = h2(mu,i)
            enddo
          enddo

          nrorb_init_alpha = nrorb_alpha
          nrorb_init_beta  = nrorb_beta

          do mu=1, nrprime
            do i=1, nrorb_init_alpha
              phi_alpha(mu,i) = h2(mu,i)
            enddo
          enddo
          do mu=1, nrprime
            do i=1, nrorb_init_beta
              phi_beta(mu,i) = h2(mu,i)
            enddo
          enddo

          do mu=1, nrprime
            do i=1, nrorb_init_beta
               phi_spinorbital(mu,(2*i-1) )   = h2(mu,i)
               phi_spinorbital(mu,2*i)        = h2(mu,i)
            enddo
          enddo

    ! normalize
          do i=1,nrorb
            norm = 0.0_dp
            do mu=1,nrprime
              norm = norm + dconjg(phi(mu,i))*phi(mu,i)
            enddo
            norm = dsqrt(norm)
          end do

          do i=1,nrorb_spinorbital
            norm_spinorbital = 0.0_dp
            do mu=1,nrprime
              norm_spinorbital = norm_spinorbital + dconjg(phi_spinorbital(mu,i))*phi_spinorbital(mu,i)
            enddo
            norm_spinorbital = dsqrt(norm_spinorbital)
          end do
          call compare_scalar_real(norm,norm_spinorbital)

        else if (restart == 1) then

          call dfftw_plan_dft_1d(planf,nrprimn,auxphin,auxphin2,fftw_forward,0)
          call dfftw_plan_dft_1d(planb,nrprimn,auxphin2,auxphin3,fftw_backward,0)

          auxphin(:) = c0
          auxphin2(:) = c0
          auxphin3(:) = c0
          A(:) = c0
          A_spinorbital(:) = c0

          write(nnn,'(i2)') 2*nrorb
          open(newunit=spsi,file="startpsi")
          !> read in A elements from converged single SPF
          do i=1, nrindep*(nrspf-1)
            read(spsi,*) rea, ima
            A(i) = dcmplx(rea,ima)
            ! Mar-7: need to correct
            A_spinorbital(i) = dcmplx(rea,ima)
          enddo

          !> set the A elements for the second SPF to 0 (complex)
          do mu=1, nrprime
            read(spsi,'('//stri(2*nrorb)//'(e23.16,1x))') (rep(in),in=1,nrorb), (imp(in),in=1,nrorb)
            do in=1, nrorb
              phi(mu,in) = dcmplx(rep(in),imp(in))
            enddo
          enddo
          write(ncol,'(i1)') 2*(nrspf-1)
          !> fill the n-1 SPF(s) with values from previous calculation
          do ix=1, nrprimn
            read(spsi,'('//stri(2*(nrspf-1))//'(e23.16,1x))') &
                  (rep(in),in=1,nrspf-1), (imp(in),in=1,nrspf-1)
            do in=1, nrspf-1
              phin(ix,in) = dcmplx(rep(in),imp(in))
            enddo
          enddo
          close(spsi)

          !> prepare the projection operator
          if (.not. allocated(projP)) allocate(projP(nrprimn,nrprimn))

          projP(:,:) = c0
          !> create projection operator from phin of converged part
          do in=1, nrspf-1
            do ix=1, nrprimn
              do jx=1, nrprimn
                projP(ix,jx) = projP(ix,jx) + phin(ix,in)*dconjg(phin(jx,in))
              enddo
            enddo
          enddo
          do i=1, nrprimn
            auxphin(i) = phin(i,nrspf-1)
          enddo
          !> do a FFT on auxphin result is stored in auxphin2
          call dfftw_execute_dft(planf,auxphin,auxphin2)
          !> multiply it by the k-space factor
          auxphin2(:) = kx(:)*auxphin2(:)

          !> now do an inverst FFT of auxphin2 to get auxphin3
          call dfftw_execute_dft(planb,auxphin2,auxphin3)

          !> take the norm as the sum of \phi_n^* \cdot \phi_n
          norm = sum(dreal(dconjg(auxphin3(:))*auxphin3(:)))
          norm = dsqrt(norm*dr)
          phin(:,nrspf) = auxphin3(:)/norm

          !> ok, now do some stuff with the projection operator
          do i=1, nrprimn
            auxphin(i) = phin(i,nrspf)
            do j=1, nrprimn
              auxphin(i) = auxphin(i) - projP(i,j)*phin(j,nrspf)*dr
            enddo
          enddo

          deallocate(projP)

          !> do the same thing again with the normalization with whatever auxphin has become
          norm = sum(dreal(dconjg(auxphin(:))*auxphin(:)))
          norm = dsqrt(norm*dr)
          !> this is our projected initial phin
          phin(:,nrspf) = auxphin(:)/norm

          !> destroy all evidence
          call dfftw_destroy_plan(planf)
          call dfftw_destroy_plan(planb)

        endif

        open(20,file="olap.ij")
        write(20,*) 'Electronic phi overlap'
        write(20,'(a5,a5,a15)') 'MO', 'MO', 'Overlap'
        do i=1, nrorb
          do j=1, nrorb
            olap = c0
            do mu=1, nrprime
              olap = olap + dconjg(phi(mu,i))*phi(mu,j)
            enddo
            write(20,'(i5,i5,f15.7)') i, j, cdabs(olap)
          enddo
        enddo

        write(20,*) 'Nuclear phi overlap'
        write(20,'(a5,a5,a15)') 'SPF', 'SPF', 'Overlap'

        do i=1, nrspf
          do j=1, nrspf
            olap = c0
            do ix=1, nrprimn
              olap = olap + dconjg(phin(ix,i))*phin(ix,j)
            enddo
            write(20,'(i5,i5,f15.7)') i, j, cdabs(olap)*dr
          enddo
        enddo
        close(20)

        return
      end subroutine
